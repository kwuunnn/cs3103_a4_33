[
    {
        "label": "socket,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket.",
        "description": "socket.",
        "detail": "socket.",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_RELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_UNRELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "kind": 6,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "class GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,\n                 skip_threshold_ms=DEFAULT_SKIP_MS, max_buffered=1024):\n        \"\"\"\n        on_receive(channel, seq, timestamp_ms, payload_bytes)\n        \"\"\"\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(local_addr)\n        self.peer_addr = peer_addr\n        self.on_receive = on_receive or (lambda *args, **kw: None)",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "now_ms",
        "kind": 2,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "def now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,\n                 skip_threshold_ms=DEFAULT_SKIP_MS, max_buffered=1024):\n        \"\"\"\n        on_receive(channel, seq, timestamp_ms, payload_bytes)\n        \"\"\"\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self.sock.bind(local_addr)",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DATA_HDR_FMT",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DATA_HDR_FMT = \"!B H I\"     # ChannelType (1), SeqNo (2), TimestampMs (4)\nDATA_HDR_LEN = struct.calcsize(DATA_HDR_FMT)\nACK_HDR_FMT = \"!B B H I\"    # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DATA_HDR_LEN",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DATA_HDR_LEN = struct.calcsize(DATA_HDR_FMT)\nACK_HDR_FMT = \"!B B H I\"    # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_HDR_FMT",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_HDR_FMT = \"!B B H I\"    # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_HDR_LEN",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_FLAG",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_RELIABLE",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "CHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_UNRELIABLE",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "CHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,\n                 skip_threshold_ms=DEFAULT_SKIP_MS, max_buffered=1024):",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SKIP_MS",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,\n                 skip_threshold_ms=DEFAULT_SKIP_MS, max_buffered=1024):\n        \"\"\"\n        on_receive(channel, seq, timestamp_ms, payload_bytes)",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "RETX_INTERVAL_MS",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "RETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(self, local_addr=(\"0.0.0.0\", 10000), peer_addr=None, on_receive: Callable=None,\n                 skip_threshold_ms=DEFAULT_SKIP_MS, max_buffered=1024):\n        \"\"\"\n        on_receive(channel, seq, timestamp_ms, payload_bytes)\n        \"\"\"",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "load_data",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def load_data(csv_file=\"recv_log.csv\"):\n    \"\"\"Load and parse the CSV log file.\"\"\"\n    data = []\n    with open(csv_file, 'r') as f:\n        reader = csv.reader(f)\n        for row in reader:\n            if len(row) >= 5:\n                arrival = int(row[0])\n                channel = int(row[1])  # 0=reliable, 1=unreliable\n                seq = int(row[2])",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "plot_latency_over_time",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def plot_latency_over_time(data):\n    \"\"\"Plot latency over time for reliable and unreliable channels.\"\"\"\n    reliable = [d for d in data if d['channel'] == 0]\n    unreliable = [d for d in data if d['channel'] == 1]\n    plt.figure(figsize=(12, 6))\n    if reliable:\n        r_times = [(d['arrival'] - data[0]['arrival']) / 1000 for d in reliable]  # seconds\n        r_latencies = [d['latency'] for d in reliable]\n        plt.scatter(r_times, r_latencies, alpha=0.6, s=30, label='Reliable', color='blue')\n    if unreliable:",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "plot_latency_distribution",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def plot_latency_distribution(data):\n    \"\"\"Plot latency distribution histogram.\"\"\"\n    reliable = [d['latency'] for d in data if d['channel'] == 0]\n    unreliable = [d['latency'] for d in data if d['channel'] == 1]\n    fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n    # Reliable channel\n    if reliable:\n        axes[0].hist(reliable, bins=30, alpha=0.7, color='blue', edgecolor='black')\n        axes[0].axvline(np.mean(reliable), color='red', linestyle='--', \n                       label=f'Mean: {np.mean(reliable):.1f}ms')",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "plot_throughput",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def plot_throughput(data):\n    \"\"\"Plot throughput (packets per second) over time.\"\"\"\n    if not data:\n        return\n    # Calculate throughput in 1-second windows\n    start_time = data[0]['arrival']\n    end_time = data[-1]['arrival']\n    duration_sec = (end_time - start_time) / 1000\n    # Count packets in 1-second bins\n    bins = defaultdict(lambda: {'reliable': 0, 'unreliable': 0})",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "plot_sequence_timeline",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def plot_sequence_timeline(data):\n    \"\"\"Plot sequence numbers over time to visualize reordering.\"\"\"\n    reliable = [d for d in data if d['channel'] == 0]\n    unreliable = [d for d in data if d['channel'] == 1]\n    plt.figure(figsize=(12, 6))\n    if reliable:\n        r_times = [(d['arrival'] - data[0]['arrival']) / 1000 for d in reliable]\n        r_seqs = [d['seq'] for d in reliable]\n        plt.scatter(r_times, r_seqs, alpha=0.6, s=30, label='Reliable', color='blue')\n    if unreliable:",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "print_statistics",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def print_statistics(data):\n    \"\"\"Print summary statistics.\"\"\"\n    reliable = [d for d in data if d['channel'] == 0]\n    unreliable = [d for d in data if d['channel'] == 1]\n    print(\"\\n\" + \"=\"*60)\n    print(\"STATISTICS SUMMARY\")\n    print(\"=\"*60)\n    print(f\"\\nTotal Packets: {len(data)}\")\n    print(f\"  Reliable:   {len(reliable)} ({len(reliable)/len(data)*100:.1f}%)\")\n    print(f\"  Unreliable: {len(unreliable)} ({len(unreliable)/len(data)*100:.1f}%)\")",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "plot_analysis",
        "description": "plot_analysis",
        "peekOfCode": "def main():\n    csv_file = sys.argv[1] if len(sys.argv) > 1 else \"recv_log.csv\"\n    print(f\"\\nüìä Analyzing {csv_file}...\")\n    try:\n        data = load_data(csv_file)\n        if not data:\n            print(\"‚ùå No data found in CSV file!\")\n            return\n        print(f\"‚úì Loaded {len(data)} packets\\n\")\n        # Generate all plots",
        "detail": "plot_analysis",
        "documentation": {}
    },
    {
        "label": "on_receive",
        "kind": 2,
        "importPath": "receiver",
        "description": "receiver",
        "peekOfCode": "def on_receive(channel, seq, ts, payload):\n    arrival = int(time.time() * 1000)\n    if channel == CHANNEL_RELIABLE:\n        print(f\"[APP R] seq={seq} ts={ts} arrival={arrival} payload={payload.decode()}\")\n    else:\n        print(f\"[APP U] seq={seq} ts={ts} arrival={arrival} payload={payload.decode()}\")\n    # you can also append to CSV for later analysis\n    with open(LOG_CSV, \"a\", newline=\"\") as f:\n        writer = csv.writer(f)\n        writer.writerow([arrival, channel, seq, ts, payload.decode()])",
        "detail": "receiver",
        "documentation": {}
    },
    {
        "label": "LOG_CSV",
        "kind": 5,
        "importPath": "receiver",
        "description": "receiver",
        "peekOfCode": "LOG_CSV = \"recv_log.csv\"\ndef on_receive(channel, seq, ts, payload):\n    arrival = int(time.time() * 1000)\n    if channel == CHANNEL_RELIABLE:\n        print(f\"[APP R] seq={seq} ts={ts} arrival={arrival} payload={payload.decode()}\")\n    else:\n        print(f\"[APP U] seq={seq} ts={ts} arrival={arrival} payload={payload.decode()}\")\n    # you can also append to CSV for later analysis\n    with open(LOG_CSV, \"a\", newline=\"\") as f:\n        writer = csv.writer(f)",
        "detail": "receiver",
        "documentation": {}
    },
    {
        "label": "sample_on_receive",
        "kind": 2,
        "importPath": "sender",
        "description": "sender",
        "peekOfCode": "def sample_on_receive(channel, seq, ts, payload):\n    # sender might also receive ACKs via API logs; we don't need to handle here\n    pass\nif __name__ == \"__main__\":\n    if len(sys.argv) < 3:\n        print(\"usage: python sender.py <local_port> <peer_ip:peer_port> [rate_pps]\")\n        sys.exit(1)\n    local_port = int(sys.argv[1])\n    peer = sys.argv[2]\n    rate = float(sys.argv[3]) if len(sys.argv) >= 4 else 50.0",
        "detail": "sender",
        "documentation": {}
    }
]