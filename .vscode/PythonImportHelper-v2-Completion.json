[
    {
        "label": "socket,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket.",
        "description": "socket.",
        "detail": "socket.",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_RELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_UNRELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_RELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_UNRELIABLE",
        "importPath": "hudp",
        "description": "hudp",
        "isExtraImport": true,
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "GameNetAPI",
        "kind": 6,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "class GameNetAPI:\n    def __init__(\n        self,\n        local_addr=(\"0.0.0.0\", 10000),\n        peer_addr=None,\n        on_receive: Callable = None,\n        skip_threshold_ms=DEFAULT_SKIP_MS,\n        max_buffered=1024,\n    ):\n        \"\"\"",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "now_ms",
        "kind": 2,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "def now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(\n        self,\n        local_addr=(\"0.0.0.0\", 10000),\n        peer_addr=None,\n        on_receive: Callable = None,\n        skip_threshold_ms=DEFAULT_SKIP_MS,\n        max_buffered=1024,",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DATA_HDR_FMT",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DATA_HDR_FMT = \"!B H I\"  # ChannelType (1), SeqNo (2), TimestampMs (4)\nDATA_HDR_LEN = struct.calcsize(DATA_HDR_FMT)\nACK_HDR_FMT = \"!B B H I\"  # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DATA_HDR_LEN",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DATA_HDR_LEN = struct.calcsize(DATA_HDR_FMT)\nACK_HDR_FMT = \"!B B H I\"  # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_HDR_FMT",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_HDR_FMT = \"!B B H I\"  # ChannelType(1), ACK_FLAG(1), SeqNo(2), TimestampMs(4)\nACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_HDR_LEN",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_HDR_LEN = struct.calcsize(ACK_HDR_FMT)\nACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "ACK_FLAG",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "ACK_FLAG = 0xFF\n# Channel types\nCHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_RELIABLE",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "CHANNEL_RELIABLE = 0\nCHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "CHANNEL_UNRELIABLE",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "CHANNEL_UNRELIABLE = 1\n# Default params\nDEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(\n        self,",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "DEFAULT_SKIP_MS",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "DEFAULT_SKIP_MS = 200\nRETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(\n        self,\n        local_addr=(\"0.0.0.0\", 10000),\n        peer_addr=None,",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "RETX_INTERVAL_MS",
        "kind": 5,
        "importPath": "hudp",
        "description": "hudp",
        "peekOfCode": "RETX_INTERVAL_MS = 50  # retransmit every 50ms until ack or skip\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(levelname)s %(message)s\")\ndef now_ms():\n    return int(time.time() * 1000)\nclass GameNetAPI:\n    def __init__(\n        self,\n        local_addr=(\"0.0.0.0\", 10000),\n        peer_addr=None,\n        on_receive: Callable = None,",
        "detail": "hudp",
        "documentation": {}
    },
    {
        "label": "on_receive",
        "kind": 2,
        "importPath": "receiver",
        "description": "receiver",
        "peekOfCode": "def on_receive(channel, seq, ts, payload):\n    now = int(time.time() * 1000)\n    rtt = now - ts if channel == CHANNEL_RELIABLE else None\n    ch_str = \"R\" if channel == CHANNEL_RELIABLE else \"U\"\n    print(f\"[RECV {ch_str}] seq={seq} ts={ts} payload={payload} rtt={rtt}ms\")\n# Receiver binds to port 10000\nreceiver = GameNetAPI(local_addr=(\"127.0.0.1\", 10000), on_receive=on_receive)\nprint(\"Receiver running... press Ctrl+C to stop\")\ntry:\n    while True:",
        "detail": "receiver",
        "documentation": {}
    },
    {
        "label": "receiver",
        "kind": 5,
        "importPath": "receiver",
        "description": "receiver",
        "peekOfCode": "receiver = GameNetAPI(local_addr=(\"127.0.0.1\", 10000), on_receive=on_receive)\nprint(\"Receiver running... press Ctrl+C to stop\")\ntry:\n    while True:\n        time.sleep(1)\nexcept KeyboardInterrupt:\n    receiver.stop()\n    print(\"Receiver stopped\")\n    print(\"Metrics:\", receiver.get_metrics())",
        "detail": "receiver",
        "documentation": {}
    },
    {
        "label": "sender",
        "kind": 5,
        "importPath": "sender",
        "description": "sender",
        "peekOfCode": "sender = GameNetAPI(local_addr=(\"127.0.0.1\", 10001), peer_addr=(\"127.0.0.1\", 10000))\npacket_rate = 20  # packets per second\nduration = 5  # seconds\ntotal_packets = packet_rate * duration\nfor i in range(total_packets):\n    payload = {\"id\": i, \"pos\": [random.randint(0, 100), random.randint(0, 100)]}\n    reliable = random.choice([True, False])\n    seq = sender.send(str(payload).encode(), reliable=reliable)\n    ch_str = \"R\" if reliable else \"U\"\n    print(f\"[SEND {ch_str}] seq={seq} payload={payload}\")",
        "detail": "sender",
        "documentation": {}
    },
    {
        "label": "packet_rate",
        "kind": 5,
        "importPath": "sender",
        "description": "sender",
        "peekOfCode": "packet_rate = 20  # packets per second\nduration = 5  # seconds\ntotal_packets = packet_rate * duration\nfor i in range(total_packets):\n    payload = {\"id\": i, \"pos\": [random.randint(0, 100), random.randint(0, 100)]}\n    reliable = random.choice([True, False])\n    seq = sender.send(str(payload).encode(), reliable=reliable)\n    ch_str = \"R\" if reliable else \"U\"\n    print(f\"[SEND {ch_str}] seq={seq} payload={payload}\")\n    time.sleep(1 / packet_rate)",
        "detail": "sender",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 5,
        "importPath": "sender",
        "description": "sender",
        "peekOfCode": "duration = 5  # seconds\ntotal_packets = packet_rate * duration\nfor i in range(total_packets):\n    payload = {\"id\": i, \"pos\": [random.randint(0, 100), random.randint(0, 100)]}\n    reliable = random.choice([True, False])\n    seq = sender.send(str(payload).encode(), reliable=reliable)\n    ch_str = \"R\" if reliable else \"U\"\n    print(f\"[SEND {ch_str}] seq={seq} payload={payload}\")\n    time.sleep(1 / packet_rate)\ntime.sleep(2)  # wait for retransmissions/acks",
        "detail": "sender",
        "documentation": {}
    },
    {
        "label": "total_packets",
        "kind": 5,
        "importPath": "sender",
        "description": "sender",
        "peekOfCode": "total_packets = packet_rate * duration\nfor i in range(total_packets):\n    payload = {\"id\": i, \"pos\": [random.randint(0, 100), random.randint(0, 100)]}\n    reliable = random.choice([True, False])\n    seq = sender.send(str(payload).encode(), reliable=reliable)\n    ch_str = \"R\" if reliable else \"U\"\n    print(f\"[SEND {ch_str}] seq={seq} payload={payload}\")\n    time.sleep(1 / packet_rate)\ntime.sleep(2)  # wait for retransmissions/acks\nsender.stop()",
        "detail": "sender",
        "documentation": {}
    }
]